// dice.go
//
// Author: Ollivier Robert <roberto@keltia.net>
// Copyright Â© 2015 by Ollivier Robert

/*
  package describes two new types representing dices and rolls of
  said dices.
 */
package dice

import (
	"crypto/rand"
	mrand "math/rand"
	"strings"
	"strconv"
)

const (
	RE_DICE = `(?P<num>\d*)[dD](?P<dice>\d+)`
	RE_BONUS = ``
	SEED_SIZE = 8
)

// Valid dice sizes
var (
	VALID_DICES = []int{ 4, 6, 8, 10, 12, 20, 30, 100 }
)

type Dice interface {
	Roll(r Result) Result
}

type Dices []Dice

type Result struct {
	List []int
	Sum  int
}

type regularDice int

type constantDice int

// API

func NewDices() Dices {
	return make([]Dice, 0, 10)
}

func (set Dices) Append(d ...Dice) Dices {
	return append(set, d...)
}

func (cd constantDice) Roll(r Result) Result {
	return r.Append(int(cd))
}

// AleaJactaEst
func (d Dices) Roll(r Result) Result {
    r1 := r

	// Seed the thing
	mrand.Seed(keySchedule(SEED_SIZE))

    for _,dice := range d {
        r1 = dice.Roll(r1)
    }
    return r1
}

func (r Result) Append(v int) Result {
	return Result{append(r.List, v), r.Sum + v}
}

func (nd regularDice) Roll(r Result) Result {
    return r.Append(internalRoll(int(nd)))
}

type openDice struct {
    threshold int
    d Dice
}

func (td *openDice) Roll(r Result) Result {
    if r.Sum != td.threshold {
        return r
    }
    return r.Merge(td.d.Roll(Result{}))
}

func (r Result) Merge(r1 Result) Result {
    return Result { append(r.List, r1.List...) , r.Sum+r1.Sum }
}

// Generate bounded values in a fair way
// Inspired by @ns_m code on IRC
func biasedCoin(p float64) bool {
	return mrand.Float64() < p
}

// We will use the values generated by crypto/rand to derive our "rolls"
func internalRoll(sides int) int {
	i := 0
	for {
		if biasedCoin(1 / float64(sides - i)) {
			return i + 1
		}
		i++
	}
}


// private func

// check size
func isValid(size int) bool {
    for _, s := range VALID_DICES {
        if size == s {
	 	    return true
		}
    }
    return false
}

// Check for possible bonus
func checkBonus(sRoll string) (int, string) {
	var (
		bonus   int
		diceStr string
	)

	// Look for possible bonus
	parts := strings.Split(sRoll, " ")
	if len(parts) == 2 {
		if parts[1] != "" {
			var err error

			bonus64, err := strconv.ParseInt(parts[1], 10, 64)
			if err != nil {
				bonus = 0
			} else {
				bonus = int(bonus64)
			}
		}
	} else {
		bonus = 0
	}
	diceStr = parts[0]
	return bonus, diceStr
}

// "key schedule" to seed the random generator
func keySchedule(seed int) int64 {

	// Seed mrand.Seed() with these
	b := make([]byte, seed)
	if _, err := rand.Read(b); err != nil {
		return -1
	}

	// Now, b is 8 bytes long, generate a 64 bit value
	acc := int64(0)
	for _, i := range b {
		acc = int64(acc * 16) + int64(i)
	}
	return acc
}

// Public interface

// Create a new dice
func NewDice (size int) (*Dice) {
	dice := new(Dice)
	if !isValid(size) {
		return nil
	}
	dice.Size = size
	return dice
}

// Throw a dice N times
func (d *Dice) Roll (num int) *Roll {

	res := new(Roll)

	// Catch null rolls :)
	if num < 1 {
		res.Result = []int{}
		res.Sum = -1
		return res
	}

	// Seed the thing
	mrand.Seed(keySchedule(SEED_SIZE))

	// We should be properly seeded now
	res.Result = make([]int, num)

	// Generate real dice rolls
	for i := 0; i < num; i++  {
		res.Result[i] = internalRoll(d.Size)
		res.Sum += res.Result[i]
	}

	// Special case
	if num == 1 && res.Sum == 1 {
		res.Tag = "**FUMBLE**"
	}
	if num == 1 && d.Size == 20 && res.Sum == 20 {
		res.Tag = "**Natural 20**"
	}
	fmt.Printf("%v:%d", res.Result, res.Sum)
	if res.Tag != "" {
		fmt.Printf(" (%s)\n", res.Tag)
	}
	return res
}
